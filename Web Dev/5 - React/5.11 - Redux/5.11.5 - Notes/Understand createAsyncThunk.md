---
tags: 
 - react
 - redux
 - toolkit
 - note
---

Here is the easiest way to understand `createAsyncThunk`.

### The "One-Minute" Concept

Imagine you are a manager (Redux) and you have an employee (the Thunk). You want to send the employee to fetch coffee (Data) from a shop (API).

Without `createAsyncThunk`, you have to micromanage every step:

1. "I am sending you now." (Dispatch `FETCH_START`)
    
2. "If you get the coffee, tell me." (Dispatch `FETCH_SUCCESS`)
    
3. "If the shop is closed, tell me." (Dispatch `FETCH_ERROR`)
    

**`createAsyncThunk` automates this micromanagement.** You just give it the "Go fetch coffee" command, and **it automatically dispatches those three status updates for you.**

---

### 1. The Three Automatic States

When you use `createAsyncThunk`, it automatically generates three Redux action types based on the name you give it:

1. **`pending`**: "I have started working." (Show a loading spinner).
    
2. **`fulfilled`**: "I finished successfully, here is the data." (Save data).
    
3. **`rejected`**: "I failed, here is the error." (Show error message).
    

---

### 2. How to Write It (The Thunk)

You call `createAsyncThunk` with two arguments:

1. **The Name:** A string (e.g., `'users/fetchById'`). This is used to name your actions.
    
2. **The Logic:** An async function that fetches your data.
    

```ts
import { createAsyncThunk } from '@reduxjs/toolkit';

// 1. Create the Thunk
export const fetchUser = createAsyncThunk(
  'users/fetchUser', // Action Name
  async (userId: number, thunkAPI) => {
    // Async Logic
    const response = await fetch(`https://api.example.com/users/${userId}`);
    return await response.json(); // The returned value becomes the 'payload' of the fulfilled action
  }
);
```

---

### 3. How to Handle It (The Slice)

Since the thunk handles the _actions_, the slice needs to handle the _state updates_.

Because these actions (`pending`, `fulfilled`, `rejected`) are generated outside the slice, we listen for them in **`extraReducers`**.

```ts
import { createSlice } from '@reduxjs/toolkit';
import { fetchUser } from './userThunk'; // Import the thunk above

const userSlice = createSlice({
  name: 'users',
  initialState: {
    data: null,
    loading: false,
    error: null,
  },
  reducers: {
    // Standard synchronous reducers go here
  },
  extraReducers: (builder) => {
    // Listen for the "Three States" automatically generated by the thunk
    builder
      .addCase(fetchUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUser.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload; // The data returned from the API
      })
      .addCase(fetchUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  },
});
```

---

### 4. Handling Errors Properly (`rejectWithValue`)

By default, if your API call fails, the `rejected` action only contains a generic error message. If you want to pass a specific custom error from your API (like "User not found"), you use `rejectWithValue`.

```ts
export const fetchUser = createAsyncThunk(
  'users/fetchUser',
  async (userId: number, { rejectWithValue }) => {
    try {
      const response = await fetch(`...`);
      if (!response.ok) {
        // This sends the custom error text to the 'rejected' case
        return rejectWithValue('Server says: User not found!'); 
      }
      return await response.json();
    } catch (err) {
      return rejectWithValue('Network Error');
    }
  }
);
```

Then, in your slice:

```ts
.addCase(fetchUser.rejected, (state, action) => {
   // action.payload is now 'Server says: User not found!'
   state.error = action.payload; 
})
```

---

### Summary Checklist

1. **Create:** Use `createAsyncThunk(name, asyncFunction)`.
    
2. **Return:** Whatever you return in the async function becomes `action.payload` in `fulfilled`.
    
3. **Listen:** Use `extraReducers` in your slice to catch `pending`, `fulfilled`, and `rejected`.
    
4. **Dispatch:** In your component, call `dispatch(fetchUser(123))`.
    