---
tags: 
 - css
 - module 
 - note
---

### `:global()`

- Use `:global()` to write **global styles** inside a CSS Module.
    
- Example:
    
    ```css
    :global(body) {
      margin: 0;
      font-family: sans-serif;
    }
    ```
    
- Styles inside `:global()` are **not scoped** and apply everywhere.
    
- ‚úÖ Best for resetting defaults or styling 3rd-party components.

---

### Element Selectors

- You **can** use element selectors (`ul`, `p`, etc.) in CSS Modules.
    
- If written **inside a class**, they stay scoped:
    
    ```css
    .list ul { list-style: none; }
    ```
    
- If written **bare (`ul {‚Ä¶}`)**, they become **global** (not scoped).
    
- ‚úÖ Best practice: always combine element selectors with a class for proper scoping.

---

### Destructuring Styles

- You can **destructure classes** from the imported styles object.
    
- Example:
    
    ```jsx
    import { primary, secondary } from "./Button.module.css";
    // const { primary, secondary } = styles; // You can do it like this also
    <button className={primary}>Click</button>
    ```
    
- Works the same as object destructuring in JS.
    
- ‚úÖ Useful for avoiding long `styles.className` references when using many classes.

---

### Naming Conventions

- Common convention: use **camelCase** or **kebab-case** for class names.
    
- Example:
    
    ```css
    /* Button.module.css */
    .primaryButton { ... }   /* camelCase */
    .primary-button { ... }  /* kebab-case */
    ```
    
- When imported, camelCase class names can be used directly:
    
    ```jsx
    import styles from "./Button.module.css";
    <button className={styles.primaryButton}>Click</button>
    ```
    
- With kebab-case, you must use bracket notation:
    
    ```jsx
    <button className={styles["primary-button"]}>Click</button>
    ```
    
- ‚úÖ **Best practice:** use **camelCase** for easier access with dot notation.

---

### styles import from CSS Module is an object

When you import a CSS Module in React, like this:

```js
import styles from "./App.module.css";
```

- üëâ `styles` is **a JavaScript object** that maps your **class names** in the CSS file to **unique, hashed names** generated by the build system.
	- each key = the class name you wrote in your .module.css file
	- each value = a unique, automatically generated class name (a hashed string)

#### üîç Example

**App.module.css**

```css
.container {
  background: white;
  padding: 20px;
}

.title {
  color: steelblue;
  font-size: 24px;
}
```

**App.jsx**

```jsx
import styles from "./App.module.css";

export default function App() {
  return (
    <div className={styles.container}>
      <h1 className={styles.title}>Hello CSS Modules</h1>
    </div>
  );
}
```

If you `console.log(styles)` ‚Äî you‚Äôll see something like:

```js
{
  container: "App_container__3xH8x",
  title: "App_title__1a2b3"
}
```

‚úÖ That‚Äôs the **object mapping** from your local class names ‚Üí unique class names in the actual HTML.  
So React will render:

```html
<div class="App_container__3xH8x">
  <h1 class="App_title__1a2b3">Hello CSS Modules</h1>
</div>
```

#### üß† Why the Hash?

Because CSS Modules‚Äô goal is **scoping**: each component‚Äôs styles are isolated ‚Äî no accidental conflicts between `.container` classes across different components.

So:

- You write simple, reusable class names
    
- The build tool (Vite, CRA, Next.js, etc.) automatically generates unique class names behind the scenes
    

#### ‚öôÔ∏è Using Multiple Classes

Since `styles` is an object, you can combine them like this:

```jsx
<div className={`${styles.card} ${styles.active}`}>Content</div>
```

Or more elegantly with libraries like **clsx**:

```bash
npm i clsx
```

```jsx
import clsx from "clsx";
<div className={clsx(styles.card, isActive && styles.active)} />
```

#### üß© Mixing with Global CSS

If you have a global class (from `global.css`), combine it with module styles:

```jsx
<div className={`global-class ${styles.box}`}>...</div>
```

‚úÖ **Summary**

|Concept|Description|
|---|---|
|`styles`|An object that maps your CSS class names to unique ones|
|Value example|`{ container: "App_container__3xH8x" }`|
|Purpose|Prevent CSS name collisions (local scoping)|
|Usage|`className={styles.container}`|
