---
tags: 
 - js
 - prototype
 - advance
---

When you talk about **prototype chain**, you have to be clear:

- **Chain of instances (via `prototype`)**  
    â†’ This is about objects created with `new`.
    
- **Chain of constructors themselves (via `__proto__`)**  
    â†’ This is about functions being objects themselves.
> These help inheritance works both for regular and static methods.
---

## ðŸ”¹ A. **Instance Prototype Chain** (via `prototype` property)

This is the chain used when you create objects with `new`.

- Each function (constructor) has a `.prototype` property.
    
- Objects created with `new` will have their internal `[[Prototype]]` (`__proto__`) set to that constructorâ€™s `.prototype`.
    
- This is how **instance methods/properties** are inherited.
    

```ad-note
If youâ€™ve ever wondered why **instance methods and properties** are inherited this way, hereâ€™s the reasoning:  
Because `F.prototype` is the object used to set up the `__proto__` link of each instance, it naturally makes sense that `F.prototype` should hold all the properties and methods that instances of the class need to share.
```

### Example

```js
function Animal() {}
Animal.prototype.eat = function() {
  console.log("eating");
};

let rabbit = new Animal();

console.log(rabbit.__proto__ === Animal.prototype); // true
rabbit.eat(); // "eating"
```

ðŸ“Œ Chain here:

```text
rabbit â†’ Animal.prototype â†’ Object.prototype â†’ null
```

---

## ðŸ”¹ B. **Constructor Prototype Chain** (via `__proto__` of functions)

Since functions are objects too, each function also has its own `__proto__`.  
This creates a second chain: the **constructor chain**, used for **static methods/properties**.

```ad-note
If youâ€™ve ever wondered why the **constructor chain** is used for **static methods and properties**, hereâ€™s the reasoning:  
A class in JavaScript is essentially a constructor function, and since functions are also objects, they have their own `__proto__`. Static members belong to the class itself rather than its instances, so theyâ€™re stored on the classâ€™s `__proto__`. This allows static methods and properties to be inherited by subclasses and shared across the class hierarchy.
```

### Example

```js
class Animal {
  static category = "living being";
}

class Rabbit extends Animal {}

console.log(Rabbit.__proto__ === Animal); // true
console.log(Rabbit.category); // "living being"
```

ðŸ“Œ Chain here:

```text
Rabbit â†’ Animal â†’ Function.prototype â†’ Object.prototype â†’ null
```

### Another Example

![[Pasted image 20251229094159.png|center|600]]

```js
class Animal {
  static planet = "Earth";

  constructor(name, speed) {
    this.speed = speed;
    this.name = name;
  }

  run(speed = 0) {
    this.speed += speed;
    alert(`${this.name} runs with speed ${this.speed}.`);
  }

  static compare(animalA, animalB) {
    return animalA.speed - animalB.speed;
  }

}

// Inherit from Animal
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} hides!`);
  }
}

let rabbits = [
  new Rabbit("White Rabbit", 10),
  new Rabbit("Black Rabbit", 5)
];

rabbits.sort(Rabbit.compare);

rabbits[0].run(); // Black Rabbit runs with speed 5.

alert(Rabbit.planet); // Earth
```

So, `Rabbit extends Animal` creates two `[[Prototype]]` references:

1. `Rabbit` function prototypally inherits from `Animal` function.
2. `Rabbit.prototype` prototypally inherits from `Animal.prototype`.

As a result, inheritance works both for regular and static methods.

---

# ðŸ§© 2. Side-by-Side Comparison

| **Instance Chain**                           | **Constructor Chain**                                   |
| -------------------------------------------- | ------------------------------------------------------- |
| Built via `prototype` property               | Built via `__proto__` of function objects               |
| Used for instance methods/properties         | Used for static methods/properties                      |
| Example: `rabbit.eat()`                      | Example: `Rabbit.category`                              |
| rabbit â†’ Animal.prototype â†’ Object.prototype | Rabbit â†’ Animal â†’ Function.prototype â†’ Object.prototype |

---

# ðŸ§© 3. Unified Diagram

```
Constructor Chain (static):
Rabbit.__proto__ â†’ Animal â†’ Function.prototype â†’ Object.prototype â†’ null

Instance Chain:
rabbit.__proto__ â†’ Animal.prototype â†’ Object.prototype â†’ null
```

Notice how the **two chains run in parallel**:

- Instances climb the `.prototype` chain.
    
- Constructors climb the `__proto__` chain.
    

---

# ðŸ§© 4. Why Two Chains?

Because JavaScript separates **instance behavior** from **constructor behavior**:

- `.prototype` is for instances (shared methods).
    
- `__proto__` of functions is for constructors (static inheritance).
    

If these were merged, it would be ambiguous:

- Instances wouldnâ€™t know where to look.
    
- Static inheritance wouldnâ€™t work properly.
    

---

âœ… In short:

- **Instance chain**: powered by `.prototype`.
    
- **Constructor chain**: powered by `__proto__`.
    
- They solve different problems but connect together to make class inheritance possible.
    