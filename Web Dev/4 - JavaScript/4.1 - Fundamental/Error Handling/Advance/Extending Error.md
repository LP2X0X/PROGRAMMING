---
tags: 
 - js
 - error
 - extend
---

## 1. **Why extend Error?**

- Add **semantic meaning** → e.g., `ValidationError`, `AuthError`, `DatabaseError`.
    
- Carry **extra properties** (status code, context info, etc.).
    
- Catch specific errors with `instanceof`.
    

---

## 2. **Basic Custom Error**

As an example, let’s consider a function `readUser(json)` that should read JSON with user data.

Here’s an example of how a valid `json` may look:

```js
let json = `{ "name": "John", "age": 30 }`;
```

Internally, we’ll use `JSON.parse`. If it receives malformed `json`, then it throws `SyntaxError`. But even if `json` is syntactically correct, that doesn’t mean that it’s a valid user, right? It may miss the necessary data. For instance, it may not have `name` and `age` properties that are essential for our users.

Our function `readUser(json)` will not only read JSON, but check (“validate”) the data. If there are no required fields, or the format is wrong, then that’s an error. And that’s not a `SyntaxError`, because the data is syntactically correct, but another kind of error. We’ll call it `ValidationError` and create a class for it. An error of that kind should also carry the information about the offending field.

Our `ValidationError` class should inherit from the `Error` class.

The `Error` class is built-in, but here’s its approximate code so we can understand what we’re extending:
```js
class ValidationError extends Error {
  constructor(message) {
    super(message); // (1)
    this.name = "ValidationError"; // (2)
  }
}

function test() {
  throw new ValidationError("Whoops!");
}

try {
  test();
} catch(err) {
  alert(err.message); // Whoops!
  alert(err.name); // ValidationError
  alert(err.stack); // a list of nested calls with line numbers for each
}

// Usage
function readUser(json) {
  let user = JSON.parse(json);

  if (!user.age) {
    throw new ValidationError("No field: age");
  }
  if (!user.name) {
    throw new ValidationError("No field: name");
  }

  return user;
}

// Working example with try..catch

try {
  let user = readUser('{ "age": 25 }');
} catch (err) {
  if (err instanceof ValidationError) {
    alert("Invalid data: " + err.message); // Invalid data: No field: name
  } else if (err instanceof SyntaxError) { // (*)
    alert("JSON Syntax Error: " + err.message);
  } else {
    throw err; // unknown error, rethrow it (**)
  }
}
```

⚠️ Always call `super(message)` or the error won’t behave correctly.

````ad-note
We could also look at `err.name`, like this:

```js
// ...
// instead of (err instanceof SyntaxError)
} else if (err.name == "SyntaxError") { // (*)
// ...
```

The `instanceof` version is much better, because in the future we are going to extend `ValidationError`, make subtypes of it, like `PropertyRequiredError`. And `instanceof` check will continue to work for new inheriting classes. So that’s future-proof.

````

---

## 3. **Further inheritance**

The `ValidationError` class is very generic. Many things may go wrong. The property may be absent or it may be in a wrong format (like a string value for `age` instead of a number). Let’s make a more concrete class `PropertyRequiredError`, exactly for absent properties. It will carry additional information about the property that’s missing.
```js
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

class PropertyRequiredError extends ValidationError {
  constructor(property) {
    super("No property: " + property);
    this.name = "PropertyRequiredError";
    this.property = property;
  }
}

// Usage
function readUser(json) {
  let user = JSON.parse(json);

  if (!user.age) {
    throw new PropertyRequiredError("age");
  }
  if (!user.name) {
    throw new PropertyRequiredError("name");
  }

  return user;
}

// Working example with try..catch

try {
  let user = readUser('{ "age": 25 }');
} catch (err) {
  if (err instanceof ValidationError) {
    alert("Invalid data: " + err.message); // Invalid data: No property: name
    alert(err.name); // PropertyRequiredError
    alert(err.property); // name
  } else if (err instanceof SyntaxError) {
    alert("JSON Syntax Error: " + err.message);
  } else {
    throw err; // unknown error, rethrow it
  }
}
```

The new class `PropertyRequiredError` is easy to use: we only need to pass the property name: `new PropertyRequiredError(property)`. The human-readable `message` is generated by the constructor.

---

## 4. **Adding Custom Properties**

```js
class HttpError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.name = "HttpError";
    this.statusCode = statusCode;
  }
}

throw new HttpError("Not Found", 404);
```

Now you can check:

```js
catch (err) {
  if (err instanceof HttpError && err.statusCode === 404) {
    // handle 404
  }
}
```

---

## 5. **Important Notes**

- ✅ **Prototype chain works correctly** with `class` syntax (older ES5 ways needed hacks).
    
- ✅ `instanceof` works properly:
    
    ```js
    err instanceof Error         // true
    err instanceof ValidationError // true
    ```
    
- ⚠️ If you **transpile with Babel**, ensure proper handling of `Error` subclassing (older Babel versions had issues).
    

---

## 6. **Hierarchy Example**

You can even build a hierarchy:

```js
class AppError extends Error {
  constructor(message) {
    super(message);
    this.name = "AppError";
  }
}

class DatabaseError extends AppError {
  constructor(message, query) {
    super(message);
    this.name = "DatabaseError";
    this.query = query;
  }
}

class ConnectionError extends DatabaseError {
  constructor(message, dbUrl) {
    super(message);
    this.name = "ConnectionError";
    this.dbUrl = dbUrl;
  }
}
```

---

## Tips and Trick

It may become a bit tedious – to assign `this.name = <class name>` in every custom error class. We can avoid it by making our own “basic error” class that assigns `this.name = this.constructor.name`. And then inherit all our custom errors from it.

Let’s call it `MyError`.

Here’s the code with `MyError` and other custom error classes, simplified:
```javascript
class MyError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
}

class ValidationError extends MyError { }

class PropertyRequiredError extends ValidationError {
  constructor(property) {
    super("No property: " + property);
    this.property = property;
  }
}

// name is correct
alert( new PropertyRequiredError("field").name ); // PropertyRequiredError
```

Now custom errors are much shorter, especially `ValidationError`, as we got rid of the `"this.name = ..."` line in the constructor.

---

✅ **Summary:**

- Use `class MyError extends Error` → call `super(message)`
    
- Set `this.name` for clarity
    
- Add extra fields as needed
    
- You can build inheritance chains (`AppError → DatabaseError → ConnectionError`)
    