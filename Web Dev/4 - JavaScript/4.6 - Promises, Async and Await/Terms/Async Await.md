---
tags: 
 - js
 - asynchronous
---

## 🔹 1. What is `async/await`?

- `async/await` is **syntactic sugar** on top of **Promises**.
    
- It lets you write asynchronous code that **looks synchronous**, making it easier to read and debug.
    

---

## 🔹 2. The `async` keyword

- Declares a function that **always returns a Promise**.
    
- If you `return` a value, it’s wrapped in `Promise.resolve(value)`.
    
- If you `throw` inside, it’s wrapped in `Promise.reject(error)`.
    

```js
async function foo() {
  return 42;
}

foo().then(console.log); // 42
```

---

## 🔹 3. The `await` keyword

- Can only be used inside an `async` function.
    
- Pauses the execution of the function **until the Promise settles**.
    
- Returns the fulfilled value, or throws if the Promise rejects.
    

```js
async function foo() {
  let result = await Promise.resolve(42);
  console.log(result); // 42
}
foo();
```


````ad-note
await accepts "thenables"
- Like `promise.then`, `await` allows us to use thenable objects (those with a callable `then` method). The idea is that a third-party object may not be a promise, but promise-compatible: if it supports `.then`, that’s enough to use it with `await`:
```js
class Thenable {
  constructor(num) {
	this.num = num;
  }
  then(resolve, reject) {
	alert(resolve);
	// resolve with this.num*2 after 1000ms
	setTimeout(() => resolve(this.num * 2), 1000); // (*)
  }
}

async function f() {
  // waits for 1 second, then result becomes 2
  let result = await new Thenable(1);
  alert(result);
}

f();
```
````

---

## 🔹 4. Execution order

Even though `await` looks like it blocks, it actually uses **microtasks**.

```js
async function foo() {
  console.log("1");
  await null;
  console.log("3");
}

foo();
console.log("2");
```

Output:

```
1
2
3
```

➡️ `"3"` goes into the microtask queue after `"2"`.

---

## 🔹 5. Error handling

- If a promise resolves normally, then `await promise` returns the result. But in the case of a rejection, it throws the error, just as if there were a `throw` statement at that line.

- This code:
	```js
	async function f() {
	  await Promise.reject(new Error("Whoops!"));
	}
	```

- …is the same as this:
	```js
	async function f() {
	  throw new Error("Whoops!");
	}
	```

- In real situations, the promise may take some time before it rejects. In that case there will be a delay before `await` throws an error. Use `try...catch` with `await` for clean error handling.
	```js
	async function foo() {
	  try {
	    let data = await Promise.reject("Oops");
	    console.log(data); 
	  } catch (err) {
	    console.error("Caught:", err);
	  }
	}
	foo();
	```

- If we don’t have `try..catch`, then the promise generated by the call of the async function `f()` becomes rejected. We can append `.catch` to handle it:
	```js
	async function f() {
	  let response = await fetch('http://no-such-url');
	}
	
	// f() becomes a rejected promise
	f().catch(alert); // TypeError: failed to fetch // (*)
	```

---

## 🔹 6. Sequential vs Parallel `await`

### ❌ Sequential (slow)

```js
async function slow() {
  let a = await fetch("/a");
  let b = await fetch("/b");
}
```

👉 Runs one after another.

### ✅ Parallel (faster)

```js
async function fast() {
  let [a, b] = await Promise.all([fetch("/a"), fetch("/b")]);
}
```

👉 Both run at the same time.

---

## 🔹 7. Top-level `await` (ES2022+)

- In modern JavaScript modules (`.mjs` or `"type": "module"`), you can use `await` at the **top level**.
    

```js
let data = await fetch("/api");
```

No need to wrap inside an `async` function.

---

## 🔹 8. Gotchas

1. `await` **always yields to the event loop** → doesn’t block the thread.
    
2. Too many sequential `await`s can slow things down.
    
3. `forEach` doesn’t work with `await` (use `for...of` instead).
    

```js
// ❌ Won’t work as expected
[1,2,3].forEach(async n => {
  await new Promise(r => setTimeout(r, 1000));
  console.log(n);
});

// ✅ Works
for (let n of [1,2,3]) {
  await new Promise(r => setTimeout(r, 1000));
  console.log(n);
}
```

---

✅ **Summary**

- `async` → function always returns a Promise.
    
- `await` → pauses inside async function until Promise settles.
    
- Errors handled with `try...catch`.
    
- Use `Promise.all` for concurrency.
    
- Top-level `await` available in modern JS.
    