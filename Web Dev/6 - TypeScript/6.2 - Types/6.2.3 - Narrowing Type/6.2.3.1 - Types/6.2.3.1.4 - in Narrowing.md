---
tags: 
 - typescript
 - narrowing 
 - type
---

## üîë What Is `in` Narrowing?

**`in` narrowing** uses the JavaScript `in` operator to **narrow union types of objects** by checking whether a **property exists** on a value.

```ts
propertyName in object
```

If the property exists, TypeScript narrows the type accordingly.

---

## üß† When `in` Narrowing Is Used

Use `in` narrowing when you have:

- A **union of object types**
    
- Different objects distinguished by **unique property names**
    
- No shared discriminant like `type` or `kind`
    

---

## üîç Basic Example

```ts
type Admin = { admin: true; permissions: string[] };
type User = { username: string };

function handle(account: Admin | User) {
  if ("permissions" in account) {
    // account is Admin
    account.permissions.push("read");
  } else {
    // account is User
    console.log(account.username);
  }
}
```

### Why this works

- Only `Admin` has `permissions`
    
- TypeScript removes `User` from the `if` branch
    

---

## ‚ö†Ô∏è Property Existence, Not Value

`in` checks **existence**, not truthiness.

```ts
type A = { value?: string };
type B = { other: number };

function test(x: A | B) {
  if ("value" in x) {
    // x is A (even if value is undefined)
  }
}
```

Even optional properties still count as ‚Äúexisting‚Äù.

---

## üß± `in` vs Truthiness

```ts
if (obj.value) { ... }   // truthiness narrowing
if ("value" in obj) { } // structural narrowing
```

| Check type | What it tests     | Risk                         |
| ---------- | ----------------- | ---------------------------- |
| Truthiness | Runtime value     | Fails for `""`, `0`, `false` |
| `in`       | Property presence | Safe for optional fields     | 

---

## üß™ Narrowing with Methods

```ts
type FileLogger = { log(msg: string): void };
type HttpLogger = { send(msg: string): void };

function write(logger: FileLogger | HttpLogger) {
  if ("log" in logger) {
    logger.log("hello");
  } else {
    logger.send("hello");
  }
}
```

Methods are properties too ‚Äî fully supported.

---

## üö´ `in` Does NOT Check Prototype Chain (Type Level)

```ts
"toString" in obj // true at runtime
```

But **TypeScript does NOT use prototype info for narrowing**.

- Narrowing is based on **declared object shape**
    
- Not runtime inheritance
    

---

## ‚ö†Ô∏è Common Pitfall: Shared Property Names

```ts
type A = { id: number };
type B = { id: string };

if ("id" in x) {
  // x is still A | B
}
```

The property exists in **both**, so no narrowing occurs.

---

## üß† Best Practices

- Use `in` when:
    
    - Object unions differ by **field presence**
        
    - No explicit discriminant exists
        
- Prefer **discriminated unions** when possible
    
- Combine with `typeof` or equality checks if needed
    

---

## üß† Key Takeaways

- `in` narrows **object unions**
    
- It checks **property existence**, not value
    
- Works with optional properties and methods
    
- Does not use prototype chain
    
- Ineffective if all union members share the property
    