---
tags: 
 - typescript
 - narrowing 
 - type
---

## üîç What Is Truthiness Narrowing?

**Truthiness narrowing** is when TypeScript **narrows a union type** based on whether a value is treated as _truthy_ or _falsy_ in a conditional (`if`, `&&`, `||`, `!`).

JavaScript does this at runtime; **TypeScript mirrors that logic at the type level**.

---

## ‚öñÔ∏è Truthy vs Falsy Values (JavaScript Rules)

### ‚ùå Falsy values

These values evaluate to `false` in a condition:

- `false`
    
- `0`
    
- `""` (empty string)
    
- `null`
    
- `undefined`
    
- `NaN`
    

### ‚úÖ Truthy values

Everything else is truthy, including:

- Non-empty strings
    
- Non-zero numbers
    
- Objects `{}`, arrays `[]`, functions
    

TypeScript uses this knowledge to **remove impossible types**.

---

## üß† Basic Truthiness Narrowing

```ts
function printLength(value: string | null) {
  if (value) {
    // value is string here
    console.log(value.length);
  }
}
```

### What happened?

- `null` is falsy
    
- Inside `if (value)`, TypeScript removes `null`
    
- `value` ‚Üí `string`
    

---

## ‚ö†Ô∏è Important Pitfall: Over-Narrowing

Truthiness narrowing removes **all falsy possibilities**, not just `null` or `undefined`.

```ts
function logCount(count: number | null) {
  if (count) {
    // count is number, BUT 0 is excluded
    console.log(count);
  }
}
```

### Problem

- `0` is falsy
    
- This check **rejects valid data**
    

### Safer alternative

```ts
if (count !== null) {
  console.log(count);
}
```

---

## üîÅ Narrowing with Boolean Negation (`!`)

```ts
function process(value: string | undefined) {
  if (!value) {
    // value is undefined here
    return;
  }

  // value is string here
  console.log(value.toUpperCase());
}
```

### Key idea

- `!value` narrows to falsy types
    
- The `else` (or after return) gets the remaining types
    

---

## üîÑ Narrowing with Logical Operators

### `&&` narrowing

```ts
value && value.toUpperCase();
```

- `value` must be truthy
    
- `null` / `undefined` removed
    

### `||` fallback

```ts
const safeValue = value || "default";
```

- Result type becomes `string`
    
- Original falsy values replaced
    

---

## üß™ Truthiness Narrowing with Objects

```ts
function handle(user: { name: string } | null) {
  if (user) {
    console.log(user.name);
  }
}
```

Objects are always truthy ‚Üí safe narrowing.

---

## ‚ùó Why Boolean() Is Worse Than Truthiness

```ts
if (Boolean(value)) {
  // TypeScript does NOT narrow
}
```

### Why?

- `Boolean()` returns `boolean`
    
- TypeScript loses the connection to the original variable
    

Prefer:

```ts
if (value) { ... }
```

---

## üß† Key Takeaways

- Truthiness narrowing follows **JavaScript runtime rules**
    
- It removes **all falsy values**, not just `null`/`undefined`
    
- Can be **dangerous with numbers and empty strings**
    
- Prefer **explicit checks** when falsy values are valid data
    
- `!value` narrows the opposite branch
    
- `Boolean(value)` does **not** help TypeScript narrow
    
