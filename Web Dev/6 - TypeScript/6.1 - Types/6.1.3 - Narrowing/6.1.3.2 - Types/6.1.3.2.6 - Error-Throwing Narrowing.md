---
tags: 
 - typescript
 - narrowing 
 - type
---

## üî• What Is Error-Throwing Narrowing?

**Error-throwing narrowing** happens when TypeScript narrows types **after a code path that always throws an error**.

Once an error is thrown, execution **cannot continue**, so TypeScript removes invalid types from the remaining code.

This is a form of **control-flow‚Äìbased narrowing**.

---

## üß† Why Throwing Narrows Types

```ts
function getName(name: string | null) {
  if (name === null) {
    throw new Error("Name is required");
  }

  // name is string here
  return name.toUpperCase();
}
```

### Key reasoning

- `throw` ends execution
    
- The remaining code path **cannot contain `null`**
    
- TypeScript safely narrows `name` to `string`
    

---

## üö™ Early-Exit Pattern (Guard Clause)

```ts
function process(id?: number) {
  if (id === undefined) {
    throw new Error("Missing id");
  }

  // id is number
  return id.toFixed(2);
}
```

This is the **cleanest and safest narrowing pattern**.

---

## üß™ Narrowing `unknown` with Errors

```ts
function handle(value: unknown) {
  if (typeof value !== "string") {
    throw new Error("Expected string");
  }

  // value is string
  console.log(value.toUpperCase());
}
```

- `unknown` forces validation
    
- Throwing guarantees safe narrowing afterward
    

---

## üß∞ Assertion Functions (`asserts`)

You can **extract error-throwing narrowing** into reusable helpers.

```ts
function assertString(value: unknown): asserts value is string {
  if (typeof value !== "string") {
    throw new Error("Not a string");
  }
}

function run(input: unknown) {
  assertString(input);
  // input is string
  input.toUpperCase();
}
```

This is how **TypeScript models runtime assertions**.

---

## üîÅ Narrowing with `never`

```ts
function fail(message: string): never {
  throw new Error(message);
}

function example(value: string | number) {
  if (typeof value === "number") {
    fail("Numbers not allowed");
  }

  // value is string
  value.toUpperCase();
}
```

- Functions returning `never` **never complete**
    
- TypeScript removes those branches entirely
    

---

## ‚ö†Ô∏è What Does NOT Narrow

```ts
if (value === null) {
  console.error("Invalid");
}
// ‚ùå value is NOT narrowed
```

Why?

- Logging does not stop execution
    
- TypeScript cannot assume safety
    

Only `throw`, `return`, or `never`-functions narrow definitively.

---

## üÜö Throwing vs Truthiness

| Technique                   | Safe? | Removes falsy values? |
| --------------------------- | ----- | --------------------- |
| `if (!value)`               | ‚ùå    | Yes (dangerous)       |
| `if (value === null) throw` | ‚úÖ    | Only null             |
| `asserts` function          | ‚úÖ    | Exact                 |

---

## üß† Best Practices

- Prefer **explicit checks + throw** over truthiness
    
- Use guard clauses at function entry
    
- Use `asserts` for reusable validation
    
- Ideal for **API boundaries**, loaders, and parsers
    

---

## üß† Key Takeaways

- Throwing an error **terminates control flow**
    
- TypeScript narrows types after a throw
    
- Works especially well with `unknown`
    
- `never` functions amplify narrowing
    
- One of the **safest narrowing techniques**
    
