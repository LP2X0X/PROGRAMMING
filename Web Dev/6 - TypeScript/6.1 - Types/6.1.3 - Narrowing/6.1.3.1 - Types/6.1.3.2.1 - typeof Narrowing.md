---
tags: 
 - typescript
 - narrowing
 - type
---

### What `typeof` Narrowing Is

`typeof` narrowing is a **control-flow–based type narrowing technique** where TypeScript refines a union type by checking the **runtime type** of a value using the JavaScript `typeof` operator.

It is one of the **most fundamental and reliable** narrowing mechanisms in TypeScript.

---

### JavaScript `typeof` vs TypeScript Narrowing

- `typeof` is a **runtime JavaScript operator**
    
- TypeScript **observes** `typeof` checks
    
- Based on the condition, TypeScript **removes impossible types** from a union
    

```ts
function log(value: string | number) {
  if (typeof value === "string") {
    // value is string
    console.log(value.toUpperCase());
  } else {
    // value is number
    console.log(value.toFixed(2));
  }
}
```

---

### Supported `typeof` Checks

TypeScript only understands narrowing for these exact `typeof` results:

| `typeof x ===` | Narrows to          |
| -------------- | ------------------- |
| `"string"`     | `string`            |
| `"number"`     | `number`            |
| `"boolean"`    | `boolean`           |
| `"bigint"`     | `bigint`            |
| `"symbol"`     | `symbol`            |
| `"undefined"`  | `undefined`         |
| `"function"`   | `Function`          |
| `"object"`     | `object \| null` ⚠️ |

---

### The `object` Pitfall

In JavaScript:

```ts
typeof null === "object"; // true
```

So this does **not** remove `null`:

```ts
function process(value: object | null) {
  if (typeof value === "object") {
    // value is still object | null
  }
}
```

Correct approach:

```ts
if (typeof value === "object" && value !== null) {
  // value is object
}
```

---

### Narrowing Function Types

```ts
function call(value: string | (() => void)) {
  if (typeof value === "function") {
    value(); // callable
  } else {
    console.log(value.toUpperCase());
  }
}
```

`"function"` is especially useful when unions include callbacks.

---

### Narrowing `undefined`

```ts
function print(value: string | undefined) {
  if (typeof value === "undefined") {
    return;
  }

  // value is string
  console.log(value.length);
}
```

This is safer and more explicit than truthiness checks.

---

### `typeof` vs Truthiness Narrowing

```ts
if (value) {
  // removes "", 0, false, null, undefined
}
```

```ts
if (typeof value === "string") {
  // removes only non-strings
}
```

**Key difference**:

- Truthiness is **value-based**
    
- `typeof` is **type-based**
    

Prefer `typeof` when precision matters.

---

### `typeof` Narrowing in Complex Unions

```ts
type Input = string | number | boolean;

function handle(input: Input) {
  if (typeof input === "string") {
    input.toUpperCase();
  } else if (typeof input === "number") {
    input.toFixed();
  } else {
    input.valueOf(); // boolean
  }
}
```

TypeScript exhaustively narrows across branches.

---

### Invalid `typeof` Checks (No Narrowing)

```ts
typeof value === "array";  // ❌
typeof value === "null";   // ❌
```

These are **runtime false** and provide **no narrowing**.

Correct alternatives:

- Arrays → `Array.isArray(value)`
    
- Null → `value === null`
    

---

### Common Real-World Use Cases

- Handling API responses
    
- Parsing user input
    
- Polymorphic utility functions
    
- Defensive programming
    

---

### Mental Model

> `typeof` asks: “What primitive category is this value at runtime?”  
> TypeScript then removes all other categories from the union.

---

### Best Practices

- Use `typeof` for **primitive unions**
    
- Combine with `!== null` when checking objects
    
- Avoid replacing `typeof` with truthiness checks
    
- Prefer explicit checks in public APIs
    

---

### Key Takeaway

> **`typeof` narrowing is precise, predictable, and foundational.**  
> It should be your first choice when narrowing primitive union types.