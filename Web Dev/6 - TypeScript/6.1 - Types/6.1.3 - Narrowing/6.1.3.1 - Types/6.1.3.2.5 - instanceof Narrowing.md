---
tags: 
 - typescript
 - narrowing 
 - type
---

## üß¨ What Is `instanceof` Narrowing?

**`instanceof` narrowing** refines a variable‚Äôs type by checking whether an object was **created by a specific class (constructor)**.

```ts
value instanceof ClassName
```

If the check succeeds, TypeScript narrows the type to that class.

---

## üèóÔ∏è When `instanceof` Works Best

Use `instanceof` when dealing with:

- **Class-based types**
    
- Built-in objects (`Date`, `Error`, `Map`, etc.)
    
- Custom classes (not interfaces or type aliases)
    

It does **not** work with structural types alone.

---

## üîç Basic Example

```ts
class Dog {
  bark() {}
}

class Cat {
  meow() {}
}

function handle(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark();
  } else {
    animal.meow();
  }
}
```

### Why this works

- `Dog` and `Cat` are real runtime constructors
    
- `instanceof` checks the prototype chain
    
- TypeScript narrows correctly
    

---

## üß∞ Built-In `instanceof` Narrowing

```ts
function format(value: Date | string) {
  if (value instanceof Date) {
    value.toISOString();
  } else {
    value.toUpperCase();
  }
}
```

Common built-ins:

- `Date`
    
- `Error`
    
- `Map`, `Set`
    
- `Array`
    

---

## üö® Error Handling Pattern

```ts
function handleError(err: unknown) {
  if (err instanceof Error) {
    console.log(err.message);
  } else {
    console.log("Unknown error");
  }
}
```

This is the **recommended way** to narrow `unknown` errors.

---

## ‚ùå Why `instanceof` Does NOT Work with Interfaces

```ts
interface User {
  name: string;
}

if (value instanceof User) {
  // ‚ùå Error: User is not a constructor
}
```

### Reason

- Interfaces are **erased at runtime**
    
- No constructor exists to check against
    

---

## ‚ö†Ô∏è Pitfall: Multiple Realms / Bundles

```ts
value instanceof Array // may fail across iframes
```

- Each realm has its own constructors
    
- Rare, but important in browser / micro-frontend setups
    

Alternative:

```ts
Array.isArray(value)
```

---

## üÜö `instanceof` vs Other Narrowing

| Technique    | Checks             | Best for                      |
| ------------ | ------------------ | ----------------------------- |
| `typeof`     | Primitive types    | `string`, `number`, `boolean` |
| `in`         | Property existence | Object shape unions           |
| `instanceof` | Prototype chain    | Classes                       |
| Equality     | Literal values     | State machines                |
| Truthiness   | Runtime presence   | Nullable values               |

---

## üß† Best Practices

- Use `instanceof` **only with classes**
    
- Prefer discriminated unions for plain objects
    
- Use `instanceof Error` for error handling
    
- Avoid relying on it across execution realms
    

---

## üß† Key Takeaways

- `instanceof` narrows by **constructor identity**
    
- Requires real runtime classes
    
- Excellent for error handling and built-ins
    
- Does not work with interfaces or type aliases
    
- Complements other narrowing techniques
    
