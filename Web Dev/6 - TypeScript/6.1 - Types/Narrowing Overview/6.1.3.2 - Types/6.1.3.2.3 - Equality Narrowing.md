---
tags: 
 - typescript
 - narrowing 
 - type
---

## ‚öñÔ∏è What Is Equality Narrowing?

**Equality narrowing** is when TypeScript refines a variable‚Äôs type based on **equality or inequality comparisons**, such as:

- `===` / `!==` (strict equality ‚Äî preferred)
    
- `==` / `!=` (loose equality ‚Äî discouraged but still supported)
    

TypeScript uses the comparison to **eliminate impossible types** on each branch.

---

## üîç Strict Equality (`===`) Narrowing

```ts
function print(value: string | number) {
  if (value === "hello") {
    // value is "hello"
    value.toUpperCase();
  }
}
```

### Why this works

- `"hello"` is a string literal
    
- TypeScript narrows `value` to that exact literal type
    

---

## üîÅ Equality Between Union Variables

```ts
function compare(a: string | number, b: string | boolean) {
  if (a === b) {
    // both must be string here
    a.toUpperCase();
    b.toUpperCase();
  }
}
```

### Reasoning

- `number === boolean` is impossible
    
- Only common type is `string`
    
- TypeScript intersects the unions
    

---

## üö´ Inequality (`!==`) Narrowing

```ts
function process(id: string | null) {
  if (id !== null) {
    // id is string
    id.toUpperCase();
  }
}
```

This is **safer than truthiness checks**, especially when empty strings or `0` are valid values.

---

## ‚ùå Null and Undefined Equality Narrowing

```ts
function load(value: string | null | undefined) {
  if (value == null) {
    // value is null | undefined
    return;
  }

  // value is string
  value.toUpperCase();
}
```

### Why `== null` is special

- Matches both `null` and `undefined`
    
- Common idiom for null checks
    
- TypeScript understands this pattern
    

---

## üî• Error-Throwing Narrowing Pattern

Throwing an error **terminates the control flow**, so TypeScript narrows afterward.

```ts
function assertString(value: string | null) {
  if (value === null) {
    throw new Error("Value is missing");
  }

  // value is string
  value.toUpperCase();
}
```

### Key idea

- `throw` is a **never-returning path**
    
- Remaining code only sees valid types
    

---

## ‚ö†Ô∏è Loose Equality (`==`) Caveat

```ts
if (value == 0) {
  // value could be 0 or "0"
}
```

- JavaScript coercion applies
    
- TypeScript narrows, but less precisely
    
- Prefer `===` unless checking `null | undefined`
    

---

## üß† Literal Union Narrowing

```ts
type Status = "idle" | "loading" | "success";

function handle(status: Status) {
  if (status === "loading") {
    // status is "loading"
  }
}
```

Equality narrowing is **core to discriminated unions**.

---

## üß† Key Takeaways

- Equality narrowing works by **eliminating impossible union members**
    
- `===` / `!==` are **precise and recommended**
    
- `== null` is a valid shorthand for nullish checks
    
- Throwing errors is a **strong narrowing signal**
    
- Avoid `==` except for null checks
    
- Critical for **state machines and React logic**
    