---
tags: 
 - typescript
 - type
 - compound
---

At its core, a **Mapped Type** in TypeScript is a way to create a new type by transforming the properties of an existing type.1

Think of it exactly like using `Array.map()` in JavaScript, but instead of iterating over data to create a new array, you are **iterating over keys (properties)** to create a new type.

This is a powerful feature for keeping your code "DRY" (Don't Repeat Yourself).2 Instead of manually rewriting similar interfaces, you define a rule to generate them automatically.

---

### 1. The Syntax Breakdown

The syntax might look a bit alien at first, but it follows a specific pattern:

```ts
type MappedType = {
  [Key in UnionOfKeys]: ValueType
}
```

- **`[Key in ...]`**: This is the loop. It iterates over every key provided.3
    
- **`UnionOfKeys`**: Usually generated by `keyof T` (which gives you a list of all property names in type `T`).4
    
- **`ValueType`**: The type you want to assign to each property.5
    

````ad-note
This is equivalent to this with [[Web Dev/6 - TypeScript/6.1 - Types/6.1.1 - Types in TS/6.1.1.4 - Utility/Record|Record]] type:
```ts
type MappedType = Record<UnionOfKeys, ValueType>;
```
````

---

### 2. A Simple Example: The Boolean Switch

Imagine you have a `User` type, and you want to create a settings object where you can enable or disable features for each user property.

**Without Mapped Types (Repetitive):**

```ts
interface User {
  name: string;
  age: number;
  email: string;
}

// We have to repeat the keys manually!
interface UserFeatureFlag {
  name: boolean;
  age: boolean;
  email: boolean;
}
```

**With Mapped Types (Automated):**

```ts
type Booleanify<T> = {
  [K in keyof T]: boolean;
};

type UserFeatureFlag = Booleanify<User>;
// Result: { name: boolean; age: boolean; email: boolean; }
```

---

### 3. Modifiers: Adding and Removing Flags

Mapped types become incredibly useful when you need to change the _nature_ of the properties, such as making them all optional or read-only.6 TypeScript uses `+` (add) and `-` (remove) prefixes.

#### Example: Creating a `Mutable` type

If you have a type where everything is `readonly`, you can use a mapped type to strip that restriction away.

```ts
type ReadOnlyUser = {
  readonly id: number;
  readonly name: string;
};

// The "-readonly" syntax removes the readonly modifier
type Mutable<T> = {
  -readonly [K in keyof T]: T[K];
};

type User = Mutable<ReadOnlyUser>;
// Result: { id: number; name: string; } (No longer readonly)
```

You can do the same for optional properties (`?`).

- `[K in keyof T]?: T[K]` adds `?` (makes it optional).
    
- `[K in keyof T]-?: T[K]` removes `?` (makes it required).
    

---

### 4. Key Remapping (Renaming Keys)

In modern TypeScript (4.1+), you can even change the _names_ of the keys using the `as` clause. This is often used to create "getter" methods or transform casing.

```ts
type User = {
  name: string;
  age: number;
};

type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

type UserGetters = Getters<User>;
/* Result:
   {
     getName: () => string;
     getAge: () => number;
   }
*/
```

---

### Summary Table

| **Concept**                 | **Syntax**                     | **Description**                                     |
| --------------------------- | ------------------------------ | --------------------------------------------------- |
| **Basic Mapping**           | `[K in keyof T]: NewType`      | Changes the value type of every property.           |
| **Accessing Original Type** | `[K in keyof T]: T[K]`         | Keeps the original value type.                      |
| **Optional Modifier**       | `[K in keyof T]?: ...`         | Makes every property optional (like `Partial<T>`).  |
| **Remove Optional**         | `[K in keyof T]-?: ...`        | Makes every property required (like `Required<T>`). |
| **Readonly Modifier**       | `readonly [K in keyof T]: ...` | Makes every property readonly (like `Readonly<T>`). |

### Why use them?

1. **Single Source of Truth:** You change the original interface, and all mapped types (flags, getters, DTOs) update automatically.
    
2. **Library Creation:** They are essential when building generic utilities or libraries (like Redux or database ORMs).
    