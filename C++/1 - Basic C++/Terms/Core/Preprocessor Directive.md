---
tags:
  - cpp
  - term
  - fundamental
---
- **Preprocessor directives** (often just called _directives_) are instructions that start with a _#_ symbol and end with a newline (NOT a semicolon). These directives tell the preprocessor to perform certain text manipulation tasks and are directives for the _[[Preprocessor|preprocessor]]_.
- The preprocessor **examines the code before actual compilation of code begins** and resolves all these directives before any code is actually generated by regular statements.

```ad-note
These _preprocessor directives_ extend only across a single line of code. As soon as a newline character is found, the preprocessor directive is ends. The only way a preprocessor directive can extend through more than one line is by preceding the newline character at the end of the line by a backslash (`\`).
```

---

```ad-important
Directives are only valid from the point of definition to **the end of the file** in which they are defined.
```

#### Example

function.cpp:

```cpp
#include <iostream>

void doSomething()
{
#ifdef PRINT
    std::cout << "Printing!\n";
#endif
#ifndef PRINT
    std::cout << "Not printing!\n";
#endif
}
```

main.cpp:

```cpp
void doSomething(); // forward declaration for function doSomething()

#define PRINT

int main()
{
    doSomething();

    return 0;
}
```

The above program will print:

> Not printing!

Even though PRINT was defined in _main.cpp_, that doesnâ€™t have any impact on any of the code in _function.cpp_ (PRINT is only \#defined from the point of definition to the end of main.cpp).

---

### Common preprocessor directive
#### ðŸ”¹ 1. `#include`

Includes the contents of another file (usually a header).

```cpp
#include <iostream>     // Standard library header
#include "myheader.h"   // User-defined header
```

```ad-note
Because an \#include directive replaces the \#include directive with the content of the included file, an \#include can copy directives from the included file into the current file.
```

```ad-tip
 - Do not \#include .cpp file. There are number of reasons for this:
	- Doing so can cause naming collisions between source files.
	- In a large project it can be hard to avoid one **definition** rules (ODR) issues.
	- Any change to such a .cpp file will cause both the .cpp file and any other .cpp file that includes it to recompile, which can take a long time. Headers tend to change less often than source files.
	- It is non-conventional to do so.
```

---

#### ðŸ”¹ 2. `#define`

The _\#define_ directive can be used to create a [[Macro|macro]].

```cpp
#define PI 3.14159
#define SQUARE(x) ((x) * (x))
```


---

#### ðŸ”¹ 3. `#undef`

Undefines a macro.

```cpp
#undef PI
```

---

#### ðŸ”¹ 4. `#ifdef`, `#ifndef`, `#endif`

The [[Conditional compilation|conditional compilation]] directives allow you to specify under what conditions something will or wonâ€™t compile. 

```cpp
#ifdef DEBUG
    std::cout << "Debugging enabled\n";
#endif

#ifndef MY_HEADER_H
#define MY_HEADER_H
// header contents
#endif
```

---

#### ðŸ”¹ 5. `#if`, `#else`, `#elif`, `#endif`

Used for  [[Conditional compilation|conditional compilation]] based on [[Constant expression|constant expressions]].

```cpp
#define VERSION 2

#if VERSION == 1
    std::cout << "Version 1\n";
#elif VERSION == 2
    std::cout << "Version 2\n";
#else
    std::cout << "Unknown version\n";
#endif
```

---

#### ðŸ”¹ 6. `#pragma`

Used for compiler-specific instructions (not standardized).

```cpp
#pragma once  // Non-standard but widely supported include guard
#pragma warning(disable : 4996)  // Disable specific warning (MSVC)
```