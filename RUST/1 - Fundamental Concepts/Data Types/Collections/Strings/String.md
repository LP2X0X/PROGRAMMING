---
tags:
  - rust
  - datatype
  - string
  - fundamental
---


### ✅ 1. Definition

- The **String** type manages data allocated on the heap and as such is able to store an amount of text unknown at compile time.
- Strings in Rust are UTF-8 encoded.

```ad-note
`String` is actually implemented as a wrapper around a vector of bytes with some extra guarantees, restrictions, and capabilities.
```

---

### 🛠 2. **Creating a `String`**

- You can create a `String` from a string literal using the `from` function, like so:

```rust
let s = String::from("hello");
let s = "hello".to_string();
```

---

### ➕ 3. **Updating a `String`**

- Append with `.push_str("...")` or `.push('c')`
    
```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() appends a literal to a String // it use string slice
s.push('l'); // The `push` method takes a single character as a parameter and adds it to the `String`.

println!("{s}"); // This will print `hello, world!`
```

- Concatenate with `+`.  There are two things note noticing here:
	- First, `s2` has an `&`, meaning that we’re adding a _reference_ of the second string to the first string. The compiler then coerce the &String into a &str to match the `add` method which the operator plus use.
	- Second, we can see in the signature that `add` takes ownership of `self` because `self` does _not_ have an `&`. This means `s1` will be moved into the `add` call and will no longer be valid after that.
	```rust
	fn add(self, s: &str) -> String {
	```

- The `format!` macro works like `println!`, but instead of printing the output to the screen, it returns a `String` with the contents. The version of the code using `format!` is much easier to read, and the code generated by the `format!` macro uses references so that this call **doesn’t take ownership** of any of its parameters.
```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
let s = format!("{s1}-{s2}-{s3}");
```

```ad-warning
Clearing a string in Rust **is a mutable action** — because it **modifies the content** of the string.
```

---

### 🧠 4. **Strings Are UTF-8**

Rust strings are UTF-8 encoded, so characters may take multiple bytes.

```rust
let hello = "Здравствуйте"; // 24 bytes, 12 characters
```

---

### ❌ 5. **Indexing Is Not Allowed**

You **cannot** access a character directly with indexing (`s[0]`) because characters may be multiple bytes. Instead, use:

- `.chars()` → iterate over characters
    
- `.bytes()` → iterate over raw bytes
    

---

### 🔍 6. **Slicing Strings**

Slicing must happen at valid **character boundaries** (not arbitrary bytes), or it will panic.

```rust
let s = "Здравствуйте";
let slice = &s[0..4]; // OK (4 bytes = 2 characters)
```

```ad-warning
You should use caution when creating string slices with ranges, because doing so can crash your program.
```

---

### 📋 7. **Iterating Over Strings**

```rust
for c in "hello".chars() {
    println!("{}", c);
}
```

Use `.chars()` for Unicode characters, `.bytes()` for raw bytes.

---

### 🚫 8. **String vs Other Languages**

Rust’s String model prioritizes safety and correctness over convenience like in Python or JavaScript.
